---
title: "Var estimation with using Garch family"
author: "ElgunIsmayilov"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Importing necessary libraries
```{r libraries}
library(tidyverse)
library(zoo)
library(xts)
library(quantmod)
library(imputeTS)
library(tseries)
library(rugarch)
library(FinTS)
library(car)
library(fBasics)
```

# Import the data

```{r data}
# Define the tickers
Dow_Jones <- getSymbols("^DJI",src = "yahoo",from = "2019-01-01", to = "2024-06-01",auto.assign = FALSE)
Tmsc <- getSymbols("TSM",src = "yahoo",from = "2019-01-01", to = "2024-06-01",auto.assign = FALSE)
Pound <- getSymbols("GBPUSD=X",src = "yahoo",from = "2019-01-01", to = "2024-06-01",auto.assign = FALSE)
Silver <- getSymbols("SI=F",src = "yahoo",from = "2019-01-01", to = "2024-06-01",auto.assign = FALSE)
BNB<- getSymbols("BNB-USD",src = "yahoo",from = "2019-01-01", to = "2024-06-01",auto.assign = FALSE)
# Extract the adjusted closing prices for each symbol

```
#Handling with NA values use na_locf
```{r data cleaning}
Dow_Jones$adjusted <- na_locf(Dow_Jones$DJI.Adjusted)
Tmsc$adjusted <- na_locf(Tmsc$TSM.Adjusted)
Pound$adjusted <- na_locf(Pound$GBPUSD.X.Adjusted)
Silver$adjusted <- na_locf(Silver$SI.F.Adjusted)
BNB$adjusted <- na_locf(BNB$BNB.USD.Adjusted)
```
#Log return of ecah asset
```{r log_return}
Dow_Jones$r <- diff.xts(log(Dow_Jones$adjusted))
Tmsc$r <- diff.xts(log(Tmsc$adjusted))
Pound$r <- diff.xts(log(Pound$adjusted))
Silver$r <- diff.xts(log(Silver$adjusted))
BNB$r <- diff.xts(log(BNB$adjusted))
```

#Portfolio construction
```{r Portfolio construction}
# Calculate the combined returns of all assets
combined_returns <- Dow_Jones$r + Tmsc$r + Pound$r + Silver$r + BNB$r
# Calculate the portfolio returns with equal weights
weight <- 0.2
portfolio_returns <- combined_returns * weight
# Convert the xts object to a data frame
portfolio_df1 <- data.frame(date = index(combined_returns), portfolio_returns = coredata(portfolio_returns))
portfolio_df1 <- na.omit(portfolio_df1)
# Ensure the date column is in Date format
portfolio_df1$date <- as.Date(portfolio_df1$date)

# Removing observations after `2023-01-01`
portfolio_df <- portfolio_df1 %>%
  filter(date <= as.Date("2023-01-01"))

# Print the portfolio data frame
print(portfolio_df)

```


#Log-returns plot
```{r log-return plot}
plot(portfolio_df$r, 
     col = "red",
     major.ticks = "years", 
     grid.ticks.on = "years",
     main = "Log-returns of Portfolio")
```

#Plot of ACF for returns 
```{r ACF_return }
acf(portfolio_df$r,lag.max = 36, na.action = na.pass,col="darkblue",lwd=7,main="ACF of Portfolio returns")

acf(portfolio_df$r, lag.max = 36, na.action = na.pass, ylim = c(-0.2, 0.2),
    col = "darkblue", lwd = 7, main = "ACF of Portfolio returns")
```

#Plot of ACF for **squared returns**.
```{r ACF_return^2}
acf(portfolio_df$r^2,lag.max = 100,na.action = na.pass,col="darkblue",lwd=7,main="ACF of Portfolio squared returns")
acf(portfolio_df$r^2,lag.max = 100,na.action = na.pass,
    ylim= c(0, 0.5),col="darkblue",lwd=7,main="CF of Portfolio squared returns")

```
Lag 1,2,3,4,6,8 seems significant.
#Normality test
```{r normality test}
basicStats((portfolio_df$r))
```
Skewness is negative and we also observe strong excess kurtosis.

```{r histogram for leptekutosis}
tibble(r = as.numeric(portfolio_df$r)) %>%
  ggplot(aes(r)) +
  geom_histogram(aes(y =..density..),
                 colour = "black", 
                 fill = "pink") +
  stat_function(fun = dnorm, 
                args = list(mean = mean(portfolio_df$r), 
                            sd = sd(portfolio_df$r))) +
  theme_bw() + 
  labs(
    title = "Density of the portfolio log-returns", 
    y = "", x = "",
    caption = "source: own calculations"
  )
```
As we can see, the distribution of the returns is **highly leptokurtic**.

```{r jargue-bera}
jarque.bera.test(portfolio_df$r)
```
The null hypothesis about normality strongly rejected!

#Testing for ARCH effects.
```{r test for arch}
ArchTest(portfolio_df$r,lags = 5)
```
There is very strong evidence to reject the null-hypothesis that there are no ARCH effects in the data.

Standardization of returns.

```{r}
portfolio_df$stan <-(portfolio_df$r-mean(portfolio_df$r, na.rm=T))/ sd(portfolio_df$r, na.rm = T)

tail(portfolio_df$stan)

```
Histogram of standart return
```{r}
hist(portfolio_df$stan, prob=T, breaks = 40)
curve(dnorm(x, mean(portfolio_df$stan, na.rm= T),
            sd=sd(portfolio_df$stan, na.rm = T)),
      col="darkblue",lwd=2, add=TRUE)

```
Descriptive statistics of standardized returns .
```{r}
basicStats(portfolio_df$stan)

```
1% empirical quantile

```{r}
quantile(portfolio_df$stan,0.01, na.rm=T)

```
For comparison: 1% quantile of standard normal distribution
```{r}
qnorm(0.01,0,1)

```
# GARCH extensions




#Estimating the GARCH(1,1) model.

```{r}
spec <- ugarchspec(variance.model = list(model="sGARCH",garchOrder= c(1,1)),mean.model = list(armaOrder = c(0,0), include.mean= T),distribution.model = "norm")

portfolio_df.garch11 <- ugarchfit(spec = spec, data = na.omit(portfolio_df$r))

```

```{r}
plot(portfolio_df.garch11, which=3)
plot(portfolio_df.garch11, which=10)
plot(portfolio_df.garch11, which=11)
plot(portfolio_df.garch11, which=12)
```


## The EGARCH model
Here, first we have to define a model specification:
```{r}
spec <- ugarchspec(# variance equation
                   variance.model = list(model = "eGARCH", 
                                         garchOrder = c(1, 1)),
                   # sGARCH would stand for standard GARCH model
                   # mean equation
                   mean.model = list(armaOrder = c(0, 0), 
                                     include.mean = TRUE), 
                   # assumed distribution of errors
                   distribution.model = "norm")

```
estimate the model:
```{r}
portfolio_df.egarch11 <- ugarchfit(spec = spec, 
                           data = portfolio_df$r)
```
Now, we can see the results:
```{r}
portfolio_df.egarch11
```
News-impact curve
```{r}
plot(portfolio_df.egarch11, which = 3)
plot(portfolio_df.egarch11, which = 10)
plot(portfolio_df.egarch11, which = 11)
plot(portfolio_df.egarch11, which = 12)


```
## The GARCH-in-Mean model 

Let's first define a model specification:
```{r}
spec <- ugarchspec(# variance equation
                   variance.model = list(model = "sGARCH", 
                                         # sGARCH = standard GARCH
                                         garchOrder = c(1, 1)),
                   # mean equation - lets turn on the intercept term
                   mean.model = list(armaOrder = c(1, 0), 
                                     include.mean = TRUE,
                       # we add an element to the mean equation,
                       # which can be either stdev (archpow 1)
                       # or var (archpow=2)
                                     archm = TRUE, archpow = 1), 
                   # assumed distribution of errors
                   distribution.model = "norm")
```

Then, we can estimate the model:
```{r}
portfolio_df.garchm11 <- ugarchfit(spec = spec, 
                           data = portfolio_df$r)
```

Let's examine the results:
```{r}
portfolio_df.garchm11
```
News-impact curve
```{r}
plot(portfolio_df.garchm11, which = 3)
plot(portfolio_df.garchm11, which = 10)
plot(portfolio_df.garchm11, which = 11)
plot(portfolio_df.garchm11, which = 12)


```
## The GARCH-t model 
Let's see whether conditional distribution of the error term can be better described by the t-Student distribution.

Let's first define a model specification:
```{r}
spec <- ugarchspec(# variance equation
                   variance.model = list(model = "sGARCH", 
                                         garchOrder = c(1, 1)),
                   # mean equation
                   mean.model = list(armaOrder = c(0, 0), 
                                     include.mean = TRUE), 
                   # assumed distribution of errors
                   distribution.model = "std") # std = t-Student
```
Then, we estimate the model:
```{r}
portfolio_df.garcht11 <- ugarchfit(spec = spec, 
                           data = portfolio_df$r)
```

Model summary:
```{r}
portfolio_df.garcht11
```
News-impact curve
```{r}
plot(portfolio_df.garcht11, which = 3)
plot(portfolio_df.garcht11, which = 10)
plot(portfolio_df.garcht11, which = 11)
plot(portfolio_df.garcht11, which = 12)


```

## The EGARCH in mean-t model
Let's first define the model specification:
```{r}
spec <- ugarchspec(# variance equation
                   variance.model = list(model = "eGARCH", 
                                         garchOrder = c(2, 1)),
                   # mean equation
                   mean.model = list(armaOrder = c(1, 0), 
                                     include.mean = TRUE,
                                     archm = TRUE, archpow = 1), 
                   # assumed distribution of errors
                   distribution.model = "std") # std = t-Student
```
Now, we estimate the model:
```{r}
portfolio_df.egarchmt11 <- ugarchfit(spec = spec, 
                             data = portfolio_df$r)
```

The model summary:
```{r}
portfolio_df.egarchmt11
```
News-impact curve
```{r}
plot(portfolio_df.garcht11, which = 3)
plot(portfolio_df.garcht11, which = 10)
plot(portfolio_df.garcht11, which = 11)
plot(portfolio_df.garcht11, which = 12)


```

Now, let's compare information criteria for all models:
```{r}
compare_ICs_ugarchfit(c("portfolio_df.garch11",
                        "portfolio_df.egarch11",
                        "portfolio_df.garchm11", 
                        "portfolio_df.garcht11", 
                        "portfolio_df.egarchmt11"))
```
# VaR in the IN-SAMPLE period
```{r}
str(portfolio_df.garch11)
head(portfolio_df.garch11@fit$sigma)

```
Calculating value-at-risk (VaR).
```{r}
portfolio_df$var <- q01*portfolio_df.garch11@fit$sigma
tail(portfolio_df)

```
Plot of returns vs value-at-risk.

```{r}
plot(portfolio_df$date,portfolio_df$r,  col="red", 
     lwd=1,type="l", ylim= c(-0.1, 0.1))
abline(h = 0, lty = 2)
lines(portfolio_df$date,portfolio_df$var,col="green", type="l")

```

In how many days losses were higher than the assumed value-at-risk?

```{r}
sum(portfolio_df$r < portfolio_df$var)/ length(portfolio_df$var)

```

# VaR in the OUT-OF-SAMPLE period
Plot of conditional standard deviation and its on-day ahead prediction.
```{r}
plot(ugarchforecast(portfolio_df.garch11, na.ahead=1), which=3)

```
Plot of conditional standard deviation forecasts in the long run.
```{r}
plot(ugarchforecast(portfolio_df.garch11, n.ahead = 200), which=3)

```

We can combine them with the in-sample estimation of conditional standard deviation

```{r}
sigma.forecast.longrun <- ugarchforecast(portfolio_df.garch11, n.ahead = 500)
unconditional_sigma <- 
  sqrt(
    portfolio_df.garch11@model$pars["omega", 1] / 
      (1 - 
         portfolio_df.garch11@model$pars["alpha1", 1] -
         portfolio_df.garch11@model$pars["beta1", 1]))
plot(
  c(as.numeric(portfolio_df.garch11@fit$sigma),
    as.numeric(sigma.forecast.longrun@forecast$sigmaFor)),
  type = "l",
  ylab = "sigma")
abline(h = unconditional_sigma, col = "red")

```

Yet a better idea is to annualize all of these values. 
```{r}
plot(
  c(as.numeric(portfolio_df.garch11@fit$sigma * sqrt(252)),
    as.numeric(sigma.forecast.longrun@forecast$sigmaFor * sqrt(252))),
  type = "l",
  ylab = "sigma annualized")
abline(h = unconditional_sigma * sqrt(252), col = "red")
```

```{r}
start <- which(portfolio_df1$date == as.Date("2023-01-03"))
finish <- which(portfolio_df1$date == as.Date("2024-05-31"))

# Check if start and finish indices are found
if (length(start) == 0 || length(finish) == 0) {
  stop("Start or finish date not found in the NASDAQ data.")
}

# Subset NASDAQ directly using indices
portfolio_df3 <- portfolio_df1[start:finish, ]

# Calculate the number of days between start and finish
num_days <- finish - start + 1

if (num_days <= 0) {
  stop("Number of days is not calculated correctly.")
}
# Initialize VaR vector
VaR <- rep(NA, times = num_days)


portfolio_df3$var <- VaR
head(portfolio_df3)
```


Now, the loop below calculates predictions of VaR for the whole **OUT-OF-SAMPLE** period
```{r}
start <- which(portfolio_df1$date == as.Date("2023-01-03"))
finish <- which(portfolio_df1$date == as.Date("2024-05-31"))
portfolio_df2 <- portfolio_df1[start:finish, ]
VaR <- rep(NA, times = finish - start + 1)

mu     <- rep(NA, times = finish - start + 1)
omega  <- rep(NA, times = finish - start + 1)
alpha1 <- rep(NA, times = finish - start + 1)
beta1  <- rep(NA, times = finish - start + 1)
```

Adding VaR values to the data.frame objects.

```{r}
portfolio_df2$Var <- VaR
head(portfolio_df2)
```
Plot of returns vs. VaR in the **OUT-OF-SAMPLE** period
```{r}
plot(portfolio_df2$Date, portfolio_df2$r, col = "red", lwd = 1, type = 'l',
     ylim = c(-0.20, 0.20))
abline(h = 0, lty = 2)
lines(portfolio_df2$Date, portfolio_df2$Var, type = 'l', col = "green")
```

In how many days losses were higher than the assumed VaR? 
```{r}
sum(portfolio_df2$r < portfolio_df2$Var) / length(portfolio_df2$Var)
```